**9.代理和反射

    1. 代理是es6的，可以拦截对象的一些底层操作，在这些基础上进行一些额外的操作行为；相当于就是门的，拦住进行一次些获取、设置等底层操作；就比如获取map.id直接就是获取了， 通过proxyMap.id获取，可以在处理对象中设置get函数，进行处理，从而拦截真获取实的值；
    2. 代理是由Proxy函数创建， 参数由目标对象target和处理程序对象handle, new Proxy(target, handle); ** Proxy构造函数的prototype是undefined；
    3. 捕获器：代理之所以能够针对底层操作进行拦截并且能够进行额外的操作，就是通过捕获器来实现的，捕获器可以定义多个，定义在处理程序对象中，每个捕获器对应一种操作，例如get/set等；捕获器只有在代理对象触发有用，目标对象无法使用； 捕获器都有相应的方法参数， 例如获取捕获器get(target, props, proxy)三个参数： 分别为目标对象、属性名、代理对象；   
    4. 反射Reflect:
       1. 在代理由13中捕获器方法，这些方法可以构造新的行为，但需要遵守这个捕获器方法的原始行为； 由于有些原始方法很麻烦，因此提供了反射Api;
       2. 反射对象有13种方法的集合，比如对象的in方法对于Reflect.has; delete操作符对应着Reflect.deleteProperty
       3. 如果想创建一个可以捕获所有方法的，直接将处理程序设置为反射Reflect对象； new Proxy(obj, Reflect);
       4. 捕获器不变式: 即捕获器几乎可以改变所有基本方法行为，但是必须遵循“捕获器不变式”， 比如目标对象的属性有些限制，不可更改、删除等配置，那么捕获器就不能返回相违背的值；
       5. 可撤销代理：要中断代理对象与目标对象之间的联系，通过new Proxy（）创建代理， 其同时会暴露一个撤销含函数revoke()；一旦撤销则不可逆， const { proxy, revoke } = Proxy.revocable(target, handler); 当执行revoke函数后，代理对象再执行代理会报错；

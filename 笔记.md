js 基础
-1: null和undefined不能和0隐士转化；
0:js 引擎是单线程，模拟多线程执行(与轮转时间片有关：短时间轮流执行多个任务);

1:值类型： 原始值赋值存储于栈，先进后出，赋值 a=3;存储 a 的值到栈中为 3，然后重新赋值 a=1，a 值重新进入栈中，之前值的空间依然存在，只不过不是变量 a 了，** Map 键名任意类型 WeackMap：键名只能对象类型

2: 0/0 => NaN, 1/0 => Infinity;
**({} + {}).length：会通过tostring转化为'[object object]' + '[object object]'
**([23,34] + [3]).length：会通过tostring转化为'23,34' + '3'
**(function() {}).length：会通过查看含函数形参个数

3: 前置++和前置-- 优先于+-\*/等运算**

4:字符串比较：是通过字符串依次顺序 ASCII 比较；也就是字符串的十进制比较**

5:判断：switch 一般适用于定值的判断，if 适用于值的范围判断;

5.5: **如果用()包裹js代码，会转化为运算符; var a = (a1,a2) => 这种就是运算符(a1,a2), 其中运算符','时，取值其后者，a也就等于a2;

6:for循环语句：

​		for(let i = 0; i< 10; i++) {
​				// do something
​		}   执行顺序： 1: 先声明变量i=0；2: 然后if(i<10) { do something } 3: i++, .....直到i=10退出循环;

​       终止循环方法：一个是break,一个是修改值，让条件不成立
​      获取100以内的质数：仅能被自身和1整除的，利用双重for循环，i< 100;  j<=i
   在函数中，for循环里rturn时，循环终止；
   
7:while(条件) {

​		do something

​	}；可以将for循环转化为while循环；

8: 未定义的变量a; 打印console.log(a)=> a is not defined; 打印console.log(typeof a) => undefined；打印console.log(typeof(typeof a)) => string；

9:高内聚、低耦合：模块的单一责任制，实现统一功能 比如函数

10：函数作用域和作用域链：函数的作用域[[scope]]在函数定义的时候已经形成，同时存储作用域链的scope chain已经存在的GO(全局活动对象)；然后再函数执行之前，就会存储函数自身的活动对象到作用域最顶端，将GO活动对象压倒作用域链底，当函数执行完毕时，函数活动对象销毁；

11：函数行参有默认值时，实参为undefined时，执行函数采用的默认值；

12：在函数内部直接给变量赋值，并且之前没有声明过该变量，那该变量则为全局变量；
		例如： function fn() {
   			var a = b = c = 9;
  			 // 相当于 var a = 9; b = 9; c = 9; b和c就为全局变量
		}

13：函数预编译：活动对象AO有行参/函数体内的声明变量和声明函数，其中行参和声明的变量起初都是undefined,***包括在if等会计作用的变量函数；函数活动对象创建过程：寻找行参变量声明， 实参赋值给行参，寻找函数声明，执行函数

    var tmp = new Date();
    function f() {
      console.log(tmp);
      if (false) {
        var tmp = 'hello world';
      }
    }
    f(); // undefined

14：'  '隐式转化，会转化为true;

15：作用域和作用域链：***ES5中只有全局和函数作用域；

全局：
   function a() {
      function b() {
      }
      b();
   }
   [[scope]]: 作用域   作用域链 
   1: a函数定义：     a.[[scope]]: 0 => GO
   2: a函数开始执行：  a.[[scope]]: 0 => a:A0  
                                 1 => GO
   3:b函数定义：      b.[[scope]]: 0 => a:A0  
                                 1 => GO
   4: b行数执行：      b.[[scope]]: 0 => b:AO
                                  1 => a:AO
                                   2 => GO
   5: b函数执行完毕： b.[[scope]]: 0 => a:A0  
                                 1 => GO
   6: a执行完毕：     a.[[scope]]: 0 => GO；
                    b.[[scope]] : 清除	

16: IIFE: 立即执行函数

	  1: 写法1：(function(形参) {})(实参); 写法2：(function(){}()) // w3c建议此写法，但很多采用写法1；立即执行函数也可有以返回值，只需要将立即执行函数赋值给一个变量即可:
		var a = (function() {
         rerturn num;
		 })()

       2:只有表达式函数才能立即执行，例如： var test = function() {} (); * ()包住任何函数等，都会变为表达式；

17. 自定义构造函数: 构造函数的this指向的是实例化本身，创建的实例是互不影响的。在构造函数内部this在实例化new时，指向实例化对象；在执行构造函数，没有实例化时，就指向的调用该构造函数的对象

18. 原型： 构造函数有prototype属性（原型）, 它也是个对象，构造函数的prototype属性是每个实例的共同祖先（公用），也就是实例可以继承构造函数的原型的属性和方法；因此在写构造函数时，一般需要公用的属性和方法直接写在原型上，一般需要传参的属性或者方法才写在构造函数里；原型的constructor属性（构造器）指向的是构造函数本身，其值可以更改；* 原型是属于实例对象的，而不是属于构造函数的，原型只是在等new构造函数，然后将原型赋值给实例对象的__proto__ ；__proto__就是每个实例对象的构造函数原型的容器

19. 原型自身也通过__proto__连接自身的原型， 通过__proto__去找原型里的属性，一层一层的往上找，形成了原型链；原型对象的属性为基本数据类型时，通过实例化对象修改原型上面的属性，并不会修改原型对象的属性，而是在该实例对象新增创建了一个同名属性; 原型对象的属性为引用类型时，如果实例对象通过实例对象.属性整体修改原型对象的该属性，则不会改变该原型对象的属性，只是相当于给实例对象创建一个自身的属性;如果通过修改该引用类型（也称对象，每一个对象都是键值对的组合）的某一属性，会直接修改原型上面的引用类型。Object.create(对象|null)，自定义原型，这个方法创建对象，其参数为创建对象的原型；**不是所有的对象都继承Object.prototype原型，例如const obj1 = Object.create(null), obj1的原型为null，不是Object.prototype；自己给实例对象制造__proto__是无效的，例如obj.__proto__ = { }是无效的；undefined和null不能使用toString()是因为它没有包装类（也就是没有引用类型的包装）和原型;所有引用类型的toString()方法都是不一样的，不是继承Object的；

20. this: this 就是一个指针，指向调用函数的对象，this的绑定规则：默认绑定、隐式绑定、硬绑定、new绑定四种
    默认绑定: 独立调用的函数、立即调用函数 默认this指向的window 例如foo()/(function() {})()/var fn = bar.fn,fn()....;
    隐式绑定: 函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的形式为 XXX.fun();需要注意的是：对象属性链中只有最后一层会影响到调用位置,即对象调用函数，this指向的是最后一层对象,例如obj1.obj2.fn()的this指向的是obj2; 隐式绑定会出现隐式丢失；
    显式绑定：bind/call/apply,改变this指向，当指向undefined和null，依然是默认绑定规则。除了包装类和对象可以改变；
    new绑定
    绑定优先级: new > 显示绑定 > 隐式绑定 > 默认绑定

21. call/apply: call/apply进行改变this指向，call(this, a1,a2,a3....)/apply(this, [a1,a2,a3....])；this如果传null,则没有改变this；

22. 对象属性和遍历
    1. hasOwnProperty目的是排除原型上得属性，查看是否有哪些自定义属性; 
    2. 遍历对象Object时，如果使用forin遍历，不仅会遍历自身属性，还会遍历原型上可枚举得属性，Object.keys(obj)则不会；forin当值遍历对象自身属性，不遍历原型属性时;可以如下：(hasOwnProperty(key): 自身是否有该属性)
    
        for (const key in obj) {
         if(obj.hasOwnProperty(key)) {
         }
        }
	
    3. object.assign(target, ....obj) // 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。此方法会改变目标对象，原理时obj.getter获取属性，然后target的setter进行设置属性
23. 检查某个属性是否在对象或者对象原型链上，('key' in obj);

24. A instanceof B: 检查对象类型;
      判定对象类型:Object.prototype.toString.call(arr) => [object Array]; 这是因为将this改为了arr这个数组对象，但是还是调用得Object得toString方法；
      Object.prototype.toString.call(变量) 这是判断类型最好方法；

      // 判断非基本数据类型
      
      function typeOf(obj) {
        // 判断类型 [object xxxxx] 根据字符串截取
        return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
      }
      
25. callee和caller:   callee: 函数 argument.calleen返回的函数自身，它在那个函数里就是指向那个函数，argument.calleen. length是函数形参个数和函数名.length一样，而argument.length返回的是函数实参个数；***callee一般用于匿名函数的递归；caller作用是获取调用该函数的函数；例如：
    
    function a() {
       b()
    }
    a();
    function b() {
      console.log(b.caller) ; // 打印的是a函数本身，即调用b函数的函数a; 如果是全局调用，则显示null
    }
26. 浅拷贝: 拷贝一层
    //遍历原对象
    
    function copy(obj) {
        if(typeof obj !== 'object') {
          throw new Error(`${obj} is not a object`);
        }
        let newObj = obj instanceof Array ? [] : {}
        for (const key in obj) {
          if (Object.hasOwnProperty.call(obj, key)) {
            newObj[key] = obj[key]  
          }
        }
        return newObj;
      }
     
    深拷贝 es5
    // 递归深拷贝 只考虑普通对象属性，不考虑内置对象（Date, Exp）和函数。
    
    function deepCopy(obj) {
        if(typeof obj !== 'object' || obj === null ) return obj
        const newObj = Array.isArray(obj) ? [] : {};
        for (const key in obj) {
          if (Object.hasOwnProperty.call(obj, key)) {
            newObj[key] = typeof obj[key] ==="object" && obj[key] !== null ? deepCopy(obj[key]) : obj[key]
          }
        }
      return newObj
    }
    
    es6写法 
    /* 
    一般来说通过JSON.stringify以及string.parse可以实现深拷贝
    主要的思路是 递归拷贝 一层层的拷贝
    */

    function deepClone(origin,hash = new WeakMap()) {
      /* 1.对传入的参数值进行判断 */

      // 当传入的参数是null/undefined/基本数类型时 直接返回
      if (origin == null || typeof origin !== 'object') return origin;

      // 当传入的是日期格式的对象时 再将其拷贝一层
      if (origin instanceof Date) return new Date(origin);

      // 当传入的是正则表达式格式的对象时 再将其拷贝一层
      if (origin instanceof RegExp) return new RegExp(origin);

      // 如果拷贝的对象是存在,直接从weakmap中返回即可
      if (hash.has(origin)) return hash.get(origin);

      // 数组以及对象的拷贝
      let cloneObj = new origin.constructor();
      // 如果不存在 则直接保存在weakmap中
      hash.set(origin,cloneObj);
      for (const key in origin) {
        if (origin.hasOwnProperty(key)) {
          // 递归拷贝每一项的值
          cloneObj[key] = deepClone(origin[key],hash);
        }
      }
      return cloneObj;
    }

27. 数组和拷贝深入：
    1. 数组和对象申明方式都有三种方式： new Array()、Array()、[2,3,4]; 数组的方法是来源于其数组原型；
      push/unshfit: 返回值新的数组长度；修改数组； 
      sort()排序： 返回排序以后的数组；默认是按ascii码排序；
          sort(function(a, b) {
            // 必须返回一个数字
            小于0: a在前面
            大于0：b在前面
            等于0：不变
          })
          // 数组随机排序
            a.sort((a, b) => {
              const ram = Math.random();
              return ram - 0.5 > 0 ? 2 : -3;
            })

      // 实现数组的去重
      function unique(arr) {
        // 筛选第一次出现元素的位置和当前index相等的元素
        return arr.filter((item, index) => arr.indexOf(item) === index)
      }
      const uniqueArr = [...new Set(arr)];

      //数组便平化
      1. 利用flat(params); 例如：[1,[23,[23]]].flat(2)
      2. 利用递归
          // 数组便平化
          function flatArr(arr) {
            var result = [];
            arr.forEach(item => {
              if(Array.isArray(item)) {
                result = result.concat(flatArr(item));
              } else {
                result.push(item)
              }
            })
            return result
          }
      // push 返回新数组长度 修改数组
      Array.prototype.myPush = function () {
        for (let i = 0; i < arguments.length; i++) {
          // 函数调用
          this[this.length] = arguments[i];
        }
        return this.length;
      };
      // unshift 返回新数组长度 修改数组
      Array.prototype.myUnshift = function () {
        // 第一遍循环 将数组的值向后挪
        for (let i = this.length + arguments.length - 1; i >= arguments.length; i--) {
          this[i] = this[i - arguments.length]
        }
        // 新增的赋值
        for (let j = 0; j < arguments.length; j++) {
          this[j] = arguments[j]
        }
        return this.length
      };
      // pop 移除最后一项 返回移除项的值 长度为0 返回undefined
      Array.prototype.myPop = function() {
        // 判断数组长度为0 返回undefined
        if(!this.length) { 
          return undefined;
         }
        const endValue = this[this.length-1];
        // 释放值；
        this[this.length - 1] = null;
        this.length = this.length -1;
        return endValue;
      }
      // shift 移除第1项  回移除项的值 长度为0 返回undefined
      Array.prototype.myShift = function() {
        // 判断数组长度为0 返回undefined
        if(!this.length) { 
          return undefined;
        }
        const startValue = this[0];
        //错位换值
        for (let i = 1; i < this.length; i++) {
          this[i-1] = this[i]
        }
        this[this.length - 1] = null;
        this.length = this.length - 1;
        return startValue
      }
      // reverse 倒序 该方法会改变原来的数组，而不会创建新的数组
      Array.prototype.myReverse = function() {
        const len = this.length;
        const newArr = []
        for (let i = len - 1; i >= 0; i--) {
           newArr.push(this[i]) 
        }
        this.length=0;//清空原数组
        Array.prototype.splice.call(this, 0, 0 ,...newArr)
        return this;
      }

      // 数组循环遍历的方法，es5函数时默认this指向window;比如foreach等,除开reduce

      forEach 循环数组，第一个参数是回调函数， 第二参数是修改this指向
      Array.prototype.myForEach = function(callback, obj=undefined) {
        //如果没有传入回调函数，则报错
        if(!callback) throw new TypeError('undefined is not a function');
        if (typeof callback !== 'function') {
          //传入的不是函数也报错
          throw new TypeError(callback + " is not a function");
        }
        // 这里this指向数组
        const _arr = this;  
        const _len = _arr.length;
        // foreach this指向为第二个参数或者window
        const _this = obj || window;
        for (let i = 0; i < _len; i++) {
          // 循环执行回调函数， 并且改变this指向为window或者第二个参数
          callback.apply(_this, [_arr[i], i, _arr])
        }
      }
      
      map循环数组，得到新数组 不改变原数组 callback的返回值时默认需要返回的数组项；
      Array.prototype.myMap = function(callback, thisObj = undefined) {
        //如果没有传入回调函数，则报错
        if(!callback) throw new TypeError('undefined is not a function');
        if (typeof callback !== 'function') {
          //传入的不是函数也报错
          throw new TypeError(callback + " is not a function");
        }
        // 这里this指向数组
        const _arr = this;  
        const _len = _arr.length;
        // this指向为第二个参数或者window
        const _this = thisObj || window;
        // 返回的新数组
        const newArr = [];
        // 数组内每一项深拷贝 避免和原数组公用
        let item = null;
        for (let i = 0; i < _arr; i++) {
          // 深拷贝
          item = JSON.parse(JSON.stringify(_arr[i]));
          // 循环执行回调函数并且返回每项，push到新数组
          newArr.push(callback.apply(_this, [item, i ,_arr]))
        }
        // 返回新数组
        return newArr;
      }

      数组filter 不改变原数组，回调函数返回true或false；根据此结果添加新数组中；
      Array.prototype.myFilter = function (callback, thisObj = undefined) {
        //如果没有传入回调函数，则报错
        if (!callback) throw new TypeError("undefined is not a function");
        if (typeof callback !== "function") {
          //传入的不是函数也报错
          throw new TypeError(callback + " is not a function");
        }
        // 这里this指向数组
        const _arr = this;
        const _len = _arr.length;
        // this指向为第二个参数或者window
        const _this = thisObj || window;
        // 返回的新数组
        const newArr = [];
        // 数组内每一项深拷贝 避免和原数组公用
        let item = null;
        for (let i = 0; i < _len; i++) {
          // 拷贝循环当前项
          item = JSON.parse(JSON.stringify(_arr[i]));
          // 如果循环当前项时，回调函数返回true;则添加到新数组
          if (callback.apply(_this, [item, i, _arr])) {
            newArr.push(item);
          }
        }
        return newArr;
      };

      every 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试
      // 全部通过测试就返回true，一旦有一个元素不通过测试则立马返回false。
      Array.prototype.myEvery = function (callback, thisObj = undefined) {
        if (!callback) throw new TypeError("undefined is not a function");
        if (typeof callback !== "function") {
          //传入的不是函数也报错
          throw new TypeError(callback + " is not a function");
        }
        // 这里this指向数组
        const _arr = this;
        const _len = _arr.length;
        // this指向为第二个参数或者window
        const _this = thisObj || window;
        for (let i = 0; i < _len; i++) {
          // 拷贝循环当前项
          item = JSON.parse(JSON.stringify(_arr[i]));
          console.log(i);
          // 当回调函数返回false 循环结束 返回false
          if (!callback.apply(_this, [item, i, _arr])) {
            return false;
          }
        }
        // 循环全部true 则返回true
        return true;
      };

      some 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。
      // 如果没有满足条件的元素，则返回false
      Array.prototype.mySome = function(callback, thisObj=undefined) {
        if (!callback) throw new TypeError("undefined is not a function");
        if (typeof callback !== "function") {
          //传入的不是函数也报错
          throw new TypeError(callback + " is not a function");
        }
        // 这里this指向数组
        const _arr = this;
        const _len = _arr.length;
        // this指向为第二个参数或者window
        const _this = thisObj || window;
        for (let i = 0; i < _len; i++) {
          if(callback.apply(_this, [_arr[i], i, _arr])){
            return true;
          }
        }
        return false
      }

      // reduce方法对数组中的每个元素执行一个由您提供函数，将其结果汇总为单个返回值
      // reduce 数组为空且没有initialValue值时 报错Reduce of empty array with no initial value
      Array.prototype.myReduce = function(callback, initialValue){
        if (!callback) throw new TypeError("undefined is not a function");
        if (typeof callback !== "function") {
          //传入的不是函数也报错
          throw new TypeError(callback + " is not a function");
        }
        const _len = this.length;
        const _arr = this;
        let item;
        let result; // 返回值
        // 如果初始值存在
        if(initialValue || initialValue === 0 || initialValue === '') {
          result = initialValue;
        } else {
          // 如果空数组 且没有初始值 则报错
          if(!this.length) {
            throw new TypeError('Reduce of empty array with no initial value')
          }
          // 没设置初始值 则赋值第1项给初始值
          result = JSON.parse(JSON.stringify(_arr[0]));
        }
        for (let i = 0; i < _len; i++) {
          // 结果等于回调函数返回值
          result = callback(result,JSON.parse(JSON.stringify(_arr[i])), i, _arr);
        }
        return result;
      }
28. 自适应
    // 根节点字体大小
  function setFontSize() {
    // 屏幕宽度
    const cWidth = document.documentElement.clientWidth;
    if (cWidth <= 414) {
      // 小于414 自适应 为屏幕宽度/37.5
      document.documentElement.style.fontSize = cWidth / 37.5 + "px";
    } else {
	  // 当大于414 为浏览器默认字体的62.5%(16px的62.5%) 10px
      if (document.documentElement.style.fontSize != "62.5%") {
        document.documentElement.style.fontSize = "62.5%";
      }
    }
  }
  // 屏幕尺寸监听事件
  window.addEventListener("resize", setFontSize, false);
29. js抛出错误：
  throw new Error(error);  
30. promise解决异步流程化的手段；它本身不是异步（promise是同步执行的，then方法是异步执行的;构建Promise对象时,需要传入一个executor函数,主要业务流程都在executor函数中执行,这是一个同步；**如果then里面的第二个参数写了，则catch就会没响应；
    1. Promise.all(可迭代类型数据(Array/set/map));一般可以用数组,会按顺序排序执行，可以时promise对象，可以是其他数据类型，其他数据类型会默认接收为reslove;  如果其中有一个是reject,则会直接所有的直接catch；
       例子： Promise.all([
                promise1,
                '234',
                promise2
              ]).then((res) => {
                console.log(res)  //[promise1的res, '234', promise2的res]
              })
    2. Promise.race(可迭代类型数据); 它执行参数里的promise,谁先执行完返回谁，其他不执行；此方法一般使用少，可以用于测试请求速度比较
       例子：Promise.race([
                promise1,
                promise2
              ]).then((res) => {
                console.log(res)  //[promise1和promise2中先执行完成的]
              }) 
    3. await: 一个操作符，等待Promise对象产出结果的操作手段；意思是暂停async函数的执行，等待promise执行后的结果；如果等待的promise是reject状态，则会异常； async是一个通过隐式的Promise返回pendding状态,这个函数和当前作用域下的其他函数程序是异步的关系；
      promise和async/await区别：
      1 promise是ES6，async/await是ES7
      2 async/await相对于promise来讲，写法更加优雅
      3 reject状态：
          1）promise错误可以通过catch来捕捉，建议尾部捕获错误，
          2）async/await既可以用.then又可以用try-catch捕捉
es6
31. 字符串的解构赋值: const [a,b,c,d] = 'abcd'; let { length: len } = 'abcd';
32. 面试：交换变量 a=3,b=4;这两个变量交换变量，不用其他变量做中间值，可以通过es6数组解构： [b,a] = [a,b];
33. 解构赋值数组：如果右边不是可迭代的对象，使用解构会报错，例如：let [foo] = 3;解构赋值默认值：let [a=2] = [], 解构值使用默认值是使用undefined(这里是全等===)的值或者不存在值时，例如 let [a=3] = [undefined]; a => 3; let [b=3] = [null]; b => null ;
34. 解构对象: 对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果解构取值，没有该塑性，则为undefined；如果变量名不一致，需要这样写: let { foo: foo1 } = { foo: '这是变量名不一致' }; console.log(foo, foo1); // foo is not undefined  这是变量名不一致; 起默认值的设置、获取和数组解构一致，不存在或者为undefined时，为默认值，其他类型的值为该值
35. es6函数默认值fn(params = 默认值)和es5区别：es5：default = a | '默认值', 不能判断false、undefined等，而es6默认参数则能判断，而且有可读性; 默认参数不能在函数中用let 和 const重新定义；参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的 => 函数每次调用，都会重新计算默认值；函数参数默认值可以与解构赋值的默认值，function fn({x, y = 5}){}这里仅仅使用了解构，没有使用默认参数，funtion fn({x, y =5 } = { x = 3, y = 10 }) { } 这样才使用了默认值；
    例子：
    // 写法一
    function m1({x = 0, y = 0} = {}) {
      console.log(x, y)
    }
    // 写法二
    function m2({x, y} = { x: 0, y: 0 }) {
      console.log(x, y)
    }
    区别：第一种是函数默认值为空对象，而对象解构的默认值为0，0;第二种写法其函数的默认值为{ x: 0, y: 0 }，前面的为解构赋值;
函数默认参数一般写在参数末尾，如果默认参数不写末尾，且需要使用默认参时，需要显示用undefined代替参数位置，将触发该参数等于默认值； 函数如果包含默认参数，则函数的length属性，将返回没有指定默认值的参数个数,例如:
    console.log((function (a, b) {}).length) // 2
    console.log((function (a, b = 3) {}).length) // 1
函数的length指函数预期存入的参数个数，这个预期传入的参数个数就不包括默认参数
箭头函数：箭头函数有几个使用注意点。
（1）箭头函数没有自己的this对象。
  普通函数来说，内部的this指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的this对象，内部的this就是定义时上层作用域中的this。也就是说，箭头函数内部的this指向是固定的，相比之下，普通函数的this指向是可变的

（2）不可以当作构造函数，也就是说，不可以对箭头函数使用new命令，否则会抛出一个错误。
  箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。
  function foo() {
    return () => {
      return () => {
        return () => {
          console.log('id:', this.id);
        };
      };
    };
  }

  var f = foo.call({id: 1});

  var t1 = f.call({id: 2})()(); // id: 1
  var t2 = f().call({id: 3})(); // id: 1
  var t3 = f()().call({id: 4}); // id: 1
  打印1是因为都是f指向的id,即使后面修改this指向，因为箭头函数没有this指向，所以指向最外层；
（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数， 在函数return之后调用函数，且没有其他操作。例如
  function f(x){
    return g(x);
  }

迭代器Iterator：forof:只能遍历数组类型的，包括字符串/map等，不能遍历对象；只有实现了Iterator接口的对象才能够使用 for of 来进行遍历取值。Iterator 是一种接口，目的是为不同的数据结构提供统一的数据访问机制。也可以理解为 Iterator 接口主要为 for of 服务的，供for...of进行消费。javascript 语言里没有接口的概念，这里我们可以理解成它是一种特殊的对象 - 迭代器对象，返回此对象的方法叫做迭代器方法。
首先他作为一个对象，此对象具有一个next方法，每次调用 next 方法都会返回一个结果值。这个结果值是一个 object，包含两个属性，value 和 done。
value表示具体的返回值，done 是布尔类型的，表示集合是否遍历完成或者是否后续还有可用数据，没有可用数据则返回 true，否则返回 false。
另外内部会维护一个指针，用来指向当前集合的位置，每调用一次 next 方法，指针都会向后移动一个位置(可以想象成数组的索引)。
//迭代器对象   是利用方法返回一个对象 实现原理 利用闭包缓存数据
      function myIterator(list) {
        // 当前排序 利用闭包
        var i = 0;
        //返回迭代器对象 迭代器对象下有next方法
        return {
          // next方法需要返回value 和 done
          // done 是布尔类型的，表示集合是否遍历完成或者是否后续还有可用数据
          // 没有可用数据则返回 true，否则返回 false。
          next: function () {
            // 是否遍历完 未遍历完为false
            var done = i >= list.length;
            // 返回当前遍历的值
            var value = !done ? list[i++] : undefined;
            return {
              // 返回当前是否遍历完和当前项
              value,
              done
            }
          },
        };
      }
forof运行机制：当 for of执行的时候，循环过程中引擎就会自动调用这个对象上的迭代器方法Symbol.iterator， 依次执行迭代器对象的 next 方法,将 next 返回值赋值给 for of 内的变量，从而得到具体的值。例如：arr[Symbol.iterator]()方法执行返回一个迭代对象，对象中的next方法就可以获取对应的值value和done;**已默认部署 Iterator 接口的对象主要包括数组、字符串、Set、Map 、类似数组的对象（比如arguments对象、DOM NodeList 对象);对象没有该属性因为：对象可能有各种属性，不像数组的值是有序的。所以遍历的时候根本不知道如何确定他们的先后顺序，所以需要我们根据情况手动实现。*对于这些可迭代对象，默认调用可迭代Symbol.iterator方法的不止是forof，还有对可迭代对象进行解构赋值的时候，会默认调用Symbol.iterator方法。例如：
    var iterableObj = {
        items: ["红", "绿", "蓝"],
        [Symbol.iterator]: function () {
          var self = this;
          var i = 0;
          return {
            next: function () {
              var done = i >= self.items.length;
              var value = !done ? self.items[i++] : undefined;
              return {
                done: done,
                value: value,
              };
            },
          };
        },
    };
    var [d, e] = iterableObj; // 在这里解构时，默认会调用[Symbol.iterator]方法返回next方法且调用，然后返回值；
    console.log(d, e); //红 绿

35. class类：es6的类其实相当于es5的构造函数,只是写成类更加体现面向对象编程的语法；类的内部所有定义的方法（原型上的方法），都是不可枚举的,但是es5定义的原型方法是可以枚举的
      class Point {   Points是一个函数
        // constructor 构造方法 相当于构造函数自身
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
        // 这是原型上的方法 方法和方法之间不能有逗号
        toString() {
          return "(" + this.x + ", " + this.y + ")";
        }
      }
      const p1 = new Point(2,3);
constructor()、toString()、toValue()这三个方法，其实都是定义在Point.prototype上面。 

constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。constructor()方法默认返回实例对象（即this)，如果constructor()返回对象，则无法构建实例，返回基本类型则不影响;类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。类的属性名，可以采用表达式，即类的方法可以用变量名：
    let methodName = 'getArea';
    class Square {
        constructor(length) {
          // ...
        }

        [methodName]() {
          // ...
        }
    }
类class不存在变量提升（hoist），这一点与 ES5 完全不同。 
    new Foo(); // ReferenceError
    class Foo {}

类得静态方法：
类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。静态方法的this指向得是类本身，不是实例；同时静态方法可以继承给子类
      class Fn {
        constructor() {
          .....
        }
        static way() {
          console.log('此方法就是静态方法，只能类自身和其子类调用，实例不能调用')
        }
      }
      Fn.way()
类的静态属性：静态属性是Fn.xxx = xx 定义写法，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，和静态方法类型， 在类里 static props = xxxx。

类得this:默认是this指向类得实例；但是如果将类中的原型方法单独提出来调用，this指向的是当前调用函数的环境，就会导致报错，例如：
    class Logger {
      printName(name = 'there') {
        this.print(`Hello ${name}`);
      }
      print(text) {
        console.log(text);
      }
    }
    const logger = new Logger();
    const { printName } = logger;
    printName(); // TypeError: Cannot read property 'print' of undefined
    // 这里printName单独拿出来调用，导致this改变，因此报错；如果通过logger.printName()则不会

    修改this：
    1：class Logger { 
      constructor() {
       this.printName = this.printName.bind(this);
       // 将this显示指向类的实例  
      }
    }
    2：class Logger { 
      constructor() {
        this.getThis = () => this; 通过箭头函数，获取this即实例
      }
    }
class类定义实例属性可以写在类的最顶端；
      class Fn {
        count = 22;
        name = "张三丰";
        constructor() {
        }
      }

私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装;
私有方法： 方法1： // 通过_私有方法  标识私有方法 约定俗成的 不足：但是类外面还是可以调用
      class Fn {
        fn(a) {
          this._d(a)
        }
        // 通过_私有方法  标识私有方法 约定俗成的 不足：但是类外面还是可以调用
        _d(a) {
          console.log('a', a)
        }
      }
  方法2： 
     // 在类外面定义私有函数
      function d(a) {
        console.log('私有方法', a);
      }
      // 类的私有方法
      class Fn {
        fn(a) {
          // 调用类外 定义的函数 此时this指向的是实例
          d.call(this, a)
        }
      }
  方法3： 利用Symbol的唯一性，在类外面无法调用
      const bar = Symbol("bar");
        class myClass {
          // 公有方法
          foo(baz) {
            this[bar](baz);
          }
          // 私有方法
          [bar](baz) {
            console.log(baz)
          }
      }
私有属性是通过加#变量名
      class myClass {
          #count = 0;
          get value() {
            console.log('Getting the current value!');
            return this.#count;
          }
      }

Class 的继承: Class可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多;子类一般也可称为派生类，父类称为基类
      class P {
        constructor() {
          this.a = 3;
        }
      }
      class S extends P {
        constructor() {
          super();
        }
      }
  子类this必须写在super( )之后。必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。*** ES6中的派生类，就是extend的子类。派生出的构造函数不会创造新的this对象(或者说this指向的对象(这里可以回顾一下new关键字做的事情)，就是所说的"子类没有自己的this"。只有通过super()把基类创建好的this对象接下来，派生类才能像基类一样使用this来生成对象的属性。

  ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this;

  第一种情况，super作为函数调用时： super虽然代表了父类的构造函数，但是返回的是子类的实例，即super内部的this指的是子类的实例，因此super()在这里相当于父类.prototype.constructor.call(this)。第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。
      class P {
        constructor() {
          this.a = 3;
        }
        m() {
          console.log(this.a);
        }
      }
      class S extends P {
        constructor() {
          super();
          this.a = 3443;
        }
        d() {
          super.m()
        }
      }
      const s1 = new S();
      s1.d() // 3443 // 这里super作为对象调用父类的原型方法，this指向的是子类实例
      super.m()虽然调用的是P.prototype.m()，但是P.prototype.m()内部的this指向子类S的实例，导致输出的是3443，而不是3。也就是说，实际上执行的是super.print.call(this)。

36. 继承 es5和es6
   1. 原型链继承
      function Parent() {
        this.name = ['张无忌'];
      }
      Parent.prototype.getNames = function() {
        return this.name;
      }
      function Child() {
        
      }
      Child.prototype = new Parent();
      Child.prototype.constructor = Child;
      缺点：每个实例对引用类型属性的修改都会被其他的实例共享，比如c1实例：c1.name.push(233)；导致所有实例共享
    2. 借用构造函数(经典继承)
      使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型） 
      function Parent(name) {
        this.name = name
      }
      function Child(name) {
        将父类的实例给子类了
        Parent.call(this, name);
      }
      优点：
        解决了每个实例对引用类型属性的修改都会被其他的实例共享的问题子类可以向父类传参
      缺点：
        只能继承父类的实例属性和方法，不能继承原型属性/方法
    3. 组合式继承(原型链继承和借用构造函数合并)
       function Parent() {
         this.name = [3223]
       }
       function Child() {
         将父类实例复制继承
         Parent.call(this)
       }
       Child.prototype = new Parent();
       Child.prototype.constructor = Child;
       优点：
          避免原型链继承的修改引用类型的属性，同时实现了可以继承父类的原型方法属性
       缺点：需执行两次父类构造函数
    4. 原型式继承：利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型,然后实例化构造函数。
      function createObj(obj) {
        // obj就是要继承的属性方法 是浅拷贝
        // 创建一个构造函数 然后实例化空对象
        function F() {};
        F.prototype = obj;
        // 返回创建一个空对象
        return new F()
      }
      // 这是要继承的属性对象 引用类型会导致修改后 导致实例共享
      const obj = {
        name: [23] //引用值
      }
      const obj1 = createObj(obj);
      const obj2 = createObj(obj);
      缺点：和原型链类型，导致修改原型上的引用属性时，会其他实例导致共享
      *** 注：可以使用Object.create来代替上述createObj的实现
    5. 寄生式继承 
      我们可以使用Object.create来代替上述createObj的实现，原理基本上是一样的。寄生式继承其实就是在createObj的内部以某种形式来增强对象（这里的增强可以理解为添加对象的方法），最后返回增强之后的对象。

      function createEnhanceObj(o) {
          //代替原型式继承的createObj
          var clone = Object.create(o)
          clone.getName = function () {
              console.log('arzh')
          }
          return clone;
      }
      缺点: 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
    6. 寄生组合式继承:结合借用构造函数传递参数和寄生模式实现继承
      // 寄生组合继承
      function inheritPrototype(Child, Parent) {
        // 创建对象，创建父类原型的一个副本
        const prototype = Object.create(Parent.prototype);
        // 增强对象，弥补因重写原型而失去的默认的constructor 属性
        prototype.constructor = Child;
        // 将父类原型给子类
        Child.prototype = prototype;
      }
      function Parent(name) {
        this.name = name;
      }
      function Child(name) {
        Parent.call(this, name);
      }
      // 将父类原型指向子类
      inheritPrototype(Child, Parent);
      目前最完善的继承方式

    7. es6继承 super(参数1，参数2)关键字在构造方法最前面
    
